# 8 类型

本规范中有很多算法，这些算法操作属性值每一个都有相关的类型。这些值的类型在本章节中给出了明确的定义。从而进一步子类化为ECMAScript语言的类型或规范类型。

ECMAScript语言的类型对应于一些值，它们可以被使用ECMAScript语言的ECMAScript程序员直接操作。ECMAScript语言类型就是：Undefined，Null，Boolean，String，Number和Object。

规范类型对应于一些元数值，它们是在算法中用来描述ECMAScript语言结构和ECMAScript语言类型。这些规范类型有：Reference，List，Completion，Property Descriptor，Property Identifier，Lexical Environment和Environment Record。规范类型值是一些人造数值，它们在ECMAScript的实现中并没有必要对应于任何特定的实体。规范类型值也可能用来描述ECMAScript表达式求值的中间结果，这些中间结果并不能保存为对象的属性或ECMAScript语言变量值。 

本规范中，标记“Type(x)”表示“x的类型”，“type”即指定义在本章节中的ECMAScript语言或规范类型。

# 8.1 Undefined类型

Undefined类型只有一个值，即undefined。没有被赋值的任何变量的值即为undefined。

# 8.2 Null类型

Null类型只有一个值，即null。

# 8.3 Boolean类型

Boolean类型代表一个逻辑实体拥有两个值，即true或false。

# 8.4 String类型

String类型是有限个有顺序的零或多个16位无符号整数（“元素”）的集合。String类型常常用来表示一个正在运行的ECMAScript程序中的文本数据。这种情况下，字符串中的每个元素被看作是一个编码单元值（见第六章）。每个元素在序列中占据了一个位置。这些位置的索引从零开始。如果存在，第一个元素的位置为0，下一个元素为1，以此类推。字符串的长度就是这些元素（16位数值）的个数。空字符串的长度为零，因此它也不包含任何元素。

如果一个字符串含有实际的文本数据，每个元素会被看作一个单独的UTF-16编码单元。不管怎么样，这就是字符串实际的存储格式。所有在字符串之上的操作都将它们看作是无差别的16位无符号整数的序列；不能保证产生的字符串还是以常规的形式存在，也不保证“语言敏感”的结果。

> 注：设计背后的合理性就是要来保持字符串的实现是尽可能的简单和高效 

# 8.5 Number类型

Number类型事实上有18437736874454810627个值（也就是2^64-2^53+3个），这代表着在IEEE二进制浮点运算标准中制订的双精度64位格式的IEEE 754的值，并且排除9007199254740990（也就是2^53-2），它表示了IEEE标准中的“Not-a-Number”。在ECMAScript中它被表示为一个特定的NaN值。（注：NaN的值是由程序表达式NaN来产生。）在一些实现中，外部代码可能检测到不同的“Not-a-Number”之间的区别，但这些行为是依赖不同实现的；针对ECMAScript代码，所有NaN的值应该是无差别的。

还有两个特殊的值，叫作“正无穷”和“负无穷”。为了简洁和说明性的目的分别通过 +∞ 和−∞来指代这两个值。（注：这两个无穷数值是由程序表达式+Infinity和-Infinity来产生，“+”可以省略。）

其他的18437736874454810624个值（也就是2^64-2^53）是有限的。一半是正数，一半是负数；每个正有限数值都有一个对应的负有限数值，它们的绝对值相等。

请注意，同时存在正零和负零两个数。为了简洁和说明性的目的分别通过+0和-0来指代这两个值。（注意：这两个零也是由程序表达式+0和-0来产生，“+”可以省略。）

这些18437736874454810622个非零有限值（也就是2^64-2^53-2）可以分成两类：

其中的18428729675200069632个值（也就是2^64-2^54）可以用常规的形式表示为：

> s * m * 2^e

其中，s为+1或者-1，m为小于2^53大于等2^52的正整数，e为-1074~971区间中（含两端）的整数。

其余的9007199254740990个值（也就是2^53-2）也可以表示为：

> s * m * 2^e

其中，s为+1或者-1，m为小于2^52的正整数，e为-1074。

请注意，所有绝对值小于等于2^53的整数都可以表示为Number类型（整数0甚至可以表示为+0和-0）。

非零的有限数值有奇数个有效数字，表示为整数m为奇数。否则，为偶数。

在本规范中，短语“x的数值”中的x表示一个非零实数（可能是无理数如PI）就意味着按照下面的方式选取这个数值。考虑Number类型的所有的有限值的集合，去掉-0，增加两个额外的值（它们不能用Number类型所表示），也就是说2^1024（即+1 * 2^53 * 2^971）和-2^1024（即-1 * 2^53 * 2^971）。在这些数值的集合中选择一个最接近x的值。如果集合中有两个值都同等接近，则选择有偶数个有效数字的数值；出于这个目的，两个确切的数值2^1024和-2^1024看作为偶数个有效数字。最后，如果选择了2^1024，则用+∞代替；如果选择了-2^1024，则用-∞代替；如果选择了+0，当且仅当x小于零时，则用-0代替；其他情况下选择的值不做变化。结果就得到了x的数值。（该过程也正好是IEEE 754中“就近取整”模式的行为。）

有一些ECMAScript操作仅仅处理在-2^31~2^31-1区间中（含两端）的整数，或在0~2^32-1区间中（含两端）的整数。这些操作接受Number类型的任何数值，但它们首先将每个值都转换为2^32个数值中的一个。可分别参考9.5和9.6章节的ToInt32和ToUnit32操作。

# 8.6 Object类型


## 8.6.1 属性的特征值
## 8.6.2 对象的内部属性和方法


# 8.7 引用类型


## 8.7.1 GetValue(V)
## 8.7.2 PutValue(V,W)


# 8.8 列表规范类型


# 8.9 自动规范类型


# 8.10 属性描述符和属性标记符规范类型


## 8.10.1 IsAccessorDescriptor(Desc)
## 8.10.2 IsDataDescriptor(Desc)
## 8.10.3 IsGenericDescriptor(Desc)
## 8.10.4 FromPropertyDescriptor(Desc)
## 8.10.5 ToPropertyDescriptor(Obj)


# 8.11 词法环境和环境记录规范类型


# 8.12 Object内部方法的算法


## 8.12.1 \[[GetOwnProperty]](P)
## 8.12.2 \[[GetProperty]](P)
## 8.12.3 \[[Get]](P)
## 8.12.4 \[[CanPut]](P)
## 8.12.5 \[[Put]](P, V, Throw)
## 8.12.6 \[[HasProperty]](P)
## 8.12.7 \[[Delete]](P, Throw)
## 8.12.8 \[[DefaultValue]](hint)
## 8.12.9 \[[DefineOwnProperty]](P, Desc, Throw)
